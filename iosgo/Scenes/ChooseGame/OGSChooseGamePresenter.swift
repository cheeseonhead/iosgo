//
//  OGSChooseGamePresenter.swift
//  iosgo
//
//  Created by Jeffrey Wu on 2017-02-26.
//  Copyright (c) 2017 Cheeseonhead. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

fileprivate let secondsInWeek = 604800
fileprivate let secondsInDay = 86400
fileprivate let secondsInHour = 3600
fileprivate let secondsInMinute = 60

protocol OGSChooseGamePresenterInput
{
    func presentListGames(response: OGSChooseGame.ListGames.Response)
}

protocol OGSChooseGamePresenterOutput: class
{
    func displayListGames(viewModel: OGSChooseGame.ListGames.ViewModel)
}

class OGSChooseGamePresenter: OGSChooseGamePresenterInput
{
    typealias ListGames = OGSChooseGame.ListGames

    weak var output: OGSChooseGamePresenterOutput!

    func presentListGames(response: ListGames.Response)
    {
        let challengeList = createViewModelChallengeList(from: response)

        let viewModel = ListGames.ViewModel(challengeList: challengeList)

        output.displayListGames(viewModel: viewModel)
    }
}


// MARK - Create Challenges
fileprivate extension OGSChooseGamePresenter
{
    func createViewModelChallengeList(from response: ListGames.Response) -> [ListGames.ViewModel.Challenge]
    {
        let username = response.username
        let userLevel = response.userRank

        var viewModelChallenges: [ListGames.ViewModel.Challenge] = []

        for challenge in response.challenges {
            let userInfo = challenge.challengerUsername + " [" + rankString(from: challenge.challengerRank) + "]"
            let sizeString = String(challenge.width) + "x" + String(challenge.height)
            let timeString = challengeTimeString(from: challenge.timeControlParameters)
            let cellType = getCellType(for: challenge, response: response)

            let viewModelChallenge = ListGames.ViewModel.Challenge(userInfo: userInfo, sizeString: sizeString, timeString: timeString, cellType: cellType)
        }

        return viewModelChallenges
    }

    func rankString(from rank:Int) -> String
    {
        if rank < 30 {
            return "\(30 - rank)k"
        }
        else {
            return "\(rank-30)d"
        }
    }

    func getCellType(for challenge: ListGames.Response.Challenge, response: ListGames.Response) -> ListGames.ViewModel.ChallengeCellType
    {
        if challenge.challengerUsername == response.username {
            return .owner
        }
        else {
            let canAccept = (challenge.maxRank >= response.userRank && challenge.minRank <= response.userRank)

            return .other(canAccept: canAccept)
        }

    }

    typealias TimeControlParameterType = ListGames.Response.TimeControlParametersType

    func challengeTimeString(from timeType: TimeControlParameterType) -> String
    {
        switch timeType {
            case .fischer(let parameters):
                return fischerTimeString(from: parameters)
            case .simple(let parameters):
                return simpleTimeString(from: parameters)
        }
    }

    func fischerTimeString(from parameters: TimeControlParameterType.Fischer) -> String
    {
        let initialTimeString = dateStringFrom(seconds: parameters.initialTime)
        let incrementString = dateStringFrom(seconds: parameters.timeIncrement)
        let maxTimeString = dateStringFrom(seconds: parameters.maxTime)

        return "\(initialTimeString)+ \(incrementString) up to \(maxTimeString)"
    }

    func simpleTimeString(from parameters: TimeControlParameterType.Simple) -> String
    {
        let perMoveTimeString = dateStringFrom(seconds: parameters.timePerMove)

        return "\(perMoveTimeString)/move"
    }

    func dateStringFrom(seconds: Int) -> String
    {
        var dateString = ""
        var secondsLeft = seconds

        let numberOfWeeks = secondsLeft / secondsInWeek
        if numberOfWeeks > 0 {
            dateString.append("\(numberOfWeeks)wk ")
        }
        secondsLeft %= secondsInWeek

        let numberOfDays = secondsLeft / secondsInDay
        if numberOfDays > 0 {
            dateString.append("\(numberOfDays)d ")
        }
        secondsLeft %= secondsInDay

        let numberOfHours = secondsLeft / secondsInHour
        if numberOfHours > 0 {
            dateString.append("\(numberOfHours)hr ")
        }
        secondsLeft %= secondsInHour

        let numberOfMinutes = secondsLeft / secondsInMinute
        if numberOfMinutes > 0 {
            dateString.append("\(numberOfMinutes)hr ")
        }
        secondsLeft %= secondsInMinute

        if secondsLeft > 0 {
            dateString.append("\(secondsLeft)s")
        }

        dateString = dateString.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)

        return dateString
    }
}
